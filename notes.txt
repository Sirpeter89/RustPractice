-main function runs first
-rust uses macros example: println!, ! denotes macro, different from functions
-if calling function then exampleFunction()
-rust styling uses 4 spaces instead of tab
-similar to gcc C++ ahead-of-time compiled, compile .rs files with rustc <filename>.rs then run with ./<filename>
-executables can then be sent to anyone and ran even without rust

function syntax:
fn main() {
}

cargo builds code and dependencies:
cargo new <projectName> similar to mkdir
	creates new rust project that uses Cargo, organizes files for you
	source code should be in src
	configs and readme in root

can convert non-cargo projects to cargo by moving rust files to src dir
	and creating a Cargo.toml file for package/dep management

build cargo projects with cargo build cmd
	outputs executable to target/debug/<project_name>
	additionally creates lock file in root, manages dependency versions

cargo run, builds and runs executable

cargo check, checks code to see if it compiles, does not run executable
	this is faster than building, use this to check

cargo build --release, once you are ready for production, run this to create a production executable
	optimizes your code, takes longer to compile, use this to benchmark code

can checkout to other projects and build them:
	git clone <gitproject>
	cd to that dir
	cargo build

cmds learned so far:
rustup update - updates rust
rustc --version - checks version
rustc - for building simple apps that dont require cargo
cargo new <projectName> - created new cargo project
cargo build - builds project, creates Cargo.lock file
cargo run - builds and runs project
cargo check - checks for compilation errors, faster than build
cargo build --release, builds production executable

variables in rust by default are immutable, can change that by prepending mut.
let apples = 5 // immutable
let mut apples = 5 //mutable

let mut name = String::new() //creates new variable name that is a string.
	::new is an associated function of a type.

check guessing_game for more notes.

&variable means reference to variable.

references and variables are both immutable by default

let x = 5;
let y = 10;

println!("x = {} and y = {}", x, y);
example of way to print 2 values with curlys to reference values

for dependencies such as modules, need to import them into Cargo.toml. Such as rand.
	for any versions after 0.9.0 inclusive, need to explicitly state in toml file

cargo doc --open command builds all documents from dependencies and opens docs in browser.

by default integers are i32 type in rust (32 bit integers) can change this

const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
	example of Rust constant
	const convention all caps
	review: const can't be values computed at runtime; however, above is okay because that happens at compile time

fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
example of shadowing in Rust, inner scope x = 12, outer scope x = 6; this way keeps immutability

    let mut spaces = "   ";
    spaces = spaces.len();
example of invalid code, cannot mutate a variables type

RUST IS A STATICALLY TYPED LANGUAGE
	strong typing on all variables needed
example: let guess: u32 = "42".parse().expect("Not a number!");
u32 is needed or gives compiling error

Scalar Types: integers, floats, bools, and chars

	integer type variants: i8, u8 ... i128, u128 ... isize usize
	u = unsigned, i = signed

	integer literals: 1_000 same as 1000 for readability
	integer overflow u8 cannot be assigned 256, error

	floats: f32, f64 default is f64
	let x = 2.0 //f64
	let y: f32 = 3.0 //f32

	integer division rounds down to nearest integer

	booleans: bool

	chars: use 1 quote 'a' let c = 'z'
	strings: use 2 quotes

	Compound Types
	Tuples and arrays
	
	Tuples: let tup: (i32, f64, u8) = (500, 6.4, 1);  //optional type annotations
		tuples are fixed length, cannot grow or shrink after declaration

    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);

	need to destructure tuples to access values or go by index 

    let five_hundred = tup.0;

    let six_point_four = tup.1;

    let one = tup.2;

	expressions implicity return unit value () if no return value

	ARRAYS

	Arrays are fixed in length and cannot have mixed types

	let a: [i32; 5] = [1, 2, 3, 4, 5]; or let a = [1, 2, 3, 4, 5];

	let a = [3; 5]; // creates 5 elements all 3s

	same element access method a[0]
